#
# EBNF syntax, compliant with the somewhat unorthodox version supported by
# http://www.icosaedro.it/bnf_chk/bnf_chk-on-line.html. This let's me validate it,
# but has the huge disadvantage of not supported UTF-8. Having a means to perform
# even just basic validation is useful at this stage though.
#
compilation_unit = ( package dot_separated_path nl package_code ) |
                   ( test package dot_separated_path nl test_package_code ) |
                   ( main package dot_separated_path nl main_package_code ) ;

test = "test" ;

main = "main" ;

package = "package" ;

dot_separated_path = basic_alphanumeric_sequence { "." basic_alphanumeric_sequence } ;

basic_alphanumeric_sequence = { basic_alphanumeric_character } basic_alpha_character ;

basic_alpha_character = a_to_f | g_z | "_" ;

g_z = "g" .. "z" | "G" .. "Z" ;

basic_alphanumeric_character = basic_alpha_character | decimal_digit ;

nl = "\x0A" ;

#****************
#* Package code *
#****************
package_code = { using_statement } definition_block { definition_block } ;

using_statement = using dot_separated_path { "," dot_separated_path } nl ;

definition_block = enum_definition | token_definition ;

#********************
#* Enums and tokens *
#********************
enum_definition = access_modifier enum identifier enum_values outdent ;
enum_values = { enum_value } enum_value ;
enum_value = indent identifier ;

token_definition = access_modifier token identifier ;

enum = "enum" ;
token = "token" ;



#definition_block = builtin_function ; # needs expanding

builtin_function = access_modifier builtin dot_separated_path 
                   basic_alphanumeric_sequence function_parameter_list ;

access_modifier = "public" | "private" | "internal" ; 

indent = "." ; # fake definition as this would be a special token generated by the lexer
outdent = "." ; # fake definition as this would be a special token generated by the lexer

#***********************
#* Integer definitions *
#***********************
integer = [integer_magnitude_definition] integer_type_and_number ;

integer_magnitude_definition = byte | ubyte | short | ushort | int | uint | long | ulong ;

integer_type_and_number = hex hex_number |
                          octal octal_number |
                          bin binary_number |
                          decimal_number ;

hex = "hex" ;

octal = "octal" ;

bin = "bin" ;

hex_number = zero | [ "_" ] hex_digit_excluding_zero { hex_digit } ;
             
octal_number = zero | [ "_" ] octal_digit_excluding_zero { octal_digit } ;
             
binary_number = zero | [ "_" ] one { binary_digit } ;

decimal_number = zero | [ "_" ] decimal_digit_excluding_zero { decimal_digit } ;
             
hex_digit_excluding_zero = decimal_digit_excluding_zero | a_to_f ;

hex_digit = zero | hex_digit_excluding_zero ;

decimal_digit_excluding_zero = octal_digit_excluding_zero | "8" | "9" ;

decimal_digit = zero | decimal_digit_excluding_zero ;

octal_digit_excluding_zero = one | "2" .. "7" ;

octal_digit = zero | octal_digit_excluding_zero ;

binary_digit = zero | one ;

zero = "0" ;

one = "1" ;

a_to_f = "a" .. "f" | "A" .. "F" ;

#*************************************
#* Floating point number definitions *
#*************************************
floating_point_number = [ floating_point_magnitude_definition ] point_number ;

floating_point_magnitude_definition = float | double ;

point_number = decimal_number [ "." decimal_digit { decimal_digit } ] [ ( "E" | "e" ) decimal_number ] ;

#*****************
#* Builtin types *
#*****************
byte = "byte" ;
ubyte = "ubyte" ;
short = "short" ;
ushort = "ushort" ; 
int = "int" ;
uint = "uint" ;
long = "long" ;
ulong = "ulong" ;
float = "float" ;
double = "double" ;